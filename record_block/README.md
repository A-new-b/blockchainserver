# 区块存储结构

区块在数据库中，存储形式为若干字段加哈希值的形式。

存储结构：

| 字段 |               serialNumber               |        deviceId        |               time               |                    data                   |           hash           |                        previous_hash                        |
|:----:|:----------------------------------------:|:----------------------:|:--------------------------------:|:-----------------------------------------:|:------------------------:|:-----------------------------------------------------------:|
| 说明 | 数据在抵达节点服务器后立即生成的编码序号 | 提交数据的终端设备号码 |        产生数据的精确时刻        |             该条数据的详细内容            |  <sup>[1](#curr-hash)</sup>对前四个字段的sha1摘要 | <sup>[2](#prev-hash)</sup>对当前hash字段与前一次的previous_hash字段拼接后取的sha-1值 |
| 类型 |                  integer                 |        char(20)        |           timestamp(4)           | text/json，目前定text，存储json形式的data |        <sup>[3](#binary)</sup>BINARY(20)       |                         BINARY(20)                         |
| 样例 |                    10                    |       AS215d462ds      | (unix_timestamp 1583199252.6380) |         {"bp":120.25,"bg":8.252"}         | 长度为160bit的二进制数据 |                   长度为160bit的二进制数据                  |

对表格的一些解释：

1. <a name="curr-hash"></a>类似的sql操作如下。
    ```sql
    select sha1(concat(serialNumber,deviceId,time,data)) from getHashValueForEachRow;
    ```
2. <a name="prev-hash"></a>此处计算sha1，有一个问题。我们需要根据“历史摘要”来计算“新摘要”。
    需要定义一个变量“历史摘要”即可。实际计算的时候，先定义这个变量```previous_hash_variable```，设初始值等于“起始、当前”（共识时刻）的摘要。
    然后开始进行```sha1(concat(hash,previous_hash_variable))```的操作，然后立即更新这个变量，使得其值等于刚刚算完的结果，然后再根据这个计算下一个previous_hash字段。
    
3. <a name="binary"></a>mysql的BINARY数据格式，每个宽度是8bit，20宽度正好可以储存一个160位的sha-1。数据通过sha1()函数计算之后接下来使用UNHEX()处理，就可以存入到BINARY槽里了。

几点说明：
1. 所有的“哈希”功能尽可能使用sha-1算法。
2. 所有的摘要过程尽可能在数据库层面完成。
3. 编码序号不需要严格不一致，只需要起到能够辅助“时间”字段进行排序的功能就可以。
4. 为提高表性能，可以加入一个主键。主键为整数自增。
5. 项目由于使用大量的底层操作，直接采用mysql类库执行语句的方法进行数据库操作。





